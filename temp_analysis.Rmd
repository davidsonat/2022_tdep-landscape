---
title: "Rock Pool Temperature Model"
author: "Andy"
date: "12/7/2021"
output: word_document
---

```{r}
temp.df <- read.csv("temperature_data.csv")
```

First, let's take a look at some of the data and explore it for correlations.

# Histograms

## Temperature Metrics

```{r}
hist(temp.df$MinWTemp)
hist(temp.df$MeanWTemp)
hist(temp.df$MaxWTemp)

plot(MeanWTemp_C ~ MaxWTemp_C, data = temp.df)
```


For this analysis, I'm choosing to focus in on maximum water temperature as our dependent variable, because it has a nice and pretty distribution and correlates well with mean water temperature (which is sort of what we're more interested in here). We could easily use mean temperature as well, but I am hesitant to use it because it does not represent a true daily "mean", because our data were collected over 8 hour periods and not a full 24 hours.

## Predictor Variables

```{r}
hist(temp.df$MaxATemp_C)
hist(temp.df$Area_m2)
hist(temp.df$Volume_m3)
hist(temp.df$Depth_m)
hist(temp.df$PctShaded)
```


## Applying Transformations

Lots of right-skewing going on, so let's transform these variables. We'll use log +1 for Area and Depth, and either logit or arcsine for PctShaded since it's a proportion.

```{r}
temp.df$Area_cm2 <- temp.df$Area_m2 * 10000
temp.df$logArea <- log(temp.df$Area_cm2 + 1)
temp.df$logDepth <- log(temp.df$Depth_cm + 1)
temp.df$arcShade <- asin(sqrt(temp.df$PctShaded))

temp.df$Date <- as.factor(temp.df$Date)

plot(x = temp.df$ShadeCat, y = temp.df$MaxWTemp_C)
```

Arcsine seems to do a better job than logit, in this case, but it is still pretty zero inflated.

# Correlation Plots

```{r}
require(GGally)
temp2.df <- subset(temp.df, select = c("MaxWTemp_C", "MaxATemp_C", "MaxRTemp_C", "logArea", "logDepth", "arcShade", "ShadeCat"))
ggpairs(data = temp2.df)
```

Area and depth look like good predictors, as does maximum air temperature and shade. Oddly, there is also some colinearity going on with some of our predictor variables, too (e.g., area x depth, shade x depth).


# Preliminary Modeling

Let's try making a basic GLMM using these variables, with area and depth as fixed effects and maximum air temperature as a random effect. We'll take a stepwise approach to model selection.

```{r}
require(glmmTMB)
require(performance)

# Depth, Area, Shade, and Air temp 
mod1 <- glmmTMB(MaxWTemp_C ~ logDepth * logArea * arcShade + (1 | MaxATemp_C), data = temp.df )
summary(mod1)
r2(mod1)

# Depth, Shade, and Air Temp
mod2 <- glmmTMB(MaxWTemp_C ~ logDepth * arcShade + (1 | MaxATemp_C), data = temp.df )
summary(mod2)
r2(mod2)

# Area, Shade, and Air Temp
mod3 <- glmmTMB(MaxWTemp_C ~ logArea * arcShade + (1 | MaxATemp_C), data = temp.df )
summary(mod3)
r2(mod3)

# Depth, Shade, and Area
mod4 <- glmmTMB(MaxWTemp_C ~ logDepth * logArea * arcShade, data = temp.df )
summary(mod4)
r2(mod4)

# Depth, Area, and Air Temp
mod5 <- glmmTMB(MaxWTemp_C ~ logDepth * logArea + (1 | MaxATemp_C), data = temp.df )
summary(mod5)
r2(mod5)

# Depth and Shade
mod6 <- glmmTMB(MaxWTemp_C ~ logDepth * arcShade, data = temp.df )
summary(mod6)
r2(mod6)

# Depth and Air Temp
mod7 <- glmmTMB(MaxWTemp_C ~ logDepth + (1 | MaxATemp_C), data = temp.df )
summary(mod7)
r2(mod7)

# Depth and Area
mod8 <- glmmTMB(MaxWTemp_C ~ logDepth * logArea, data = temp.df )
summary(mod8)
r2(mod8)

# Area and Shade
mod9 <- glmmTMB(MaxWTemp_C ~ logArea * arcShade, data = temp.df )
summary(mod9)
r2(mod9)

# Area and Air Temp
mod10 <- glmmTMB(MaxWTemp_C ~ logArea + (1 | MaxATemp_C), data = temp.df )
summary(mod10)
r2(mod10)

# Shade and Air Temp
mod11 <- glmmTMB(MaxWTemp_C ~ arcShade + (1 | MaxATemp_C), data = temp.df )
summary(mod11)
r2(mod11)

# Area alone
mod12 <- glmmTMB(MaxWTemp_C ~ logArea, data = temp.df )
summary(mod12)
r2(mod12)

# Shade alone
mod13 <- glmmTMB(MaxWTemp_C ~ arcShade, data = temp.df )
summary(mod13)
r2(mod13)

# Depth alone
mod14 <- glmmTMB(MaxWTemp_C ~ logDepth, data = temp.df )
summary(mod14)
r2(mod14)

# Air Temp alone
mod15 <- glmmTMB(MaxWTemp_C ~ (1 | MaxATemp_C), data = temp.df )
summary(mod15)
r2(mod15)


# River Temp as a random effect instead of date/air temp
mod16 <- glmmTMB(MaxWTemp_C ~ logDepth * PctShaded + ( 1 | MaxRTemp_C ), data = temp.df )
summary(mod16)
r2(mod16)

```

Model 2, which excludes area but includes depth, has the lowest AIC. It indicates that depth and shade both negatively impact maximum water temperatures, and there is an interaction - deep, shady pools are probably especially cool. Additionally, maximum air temperature does pull out as a significant random effect. It has the second-highest r^2^ value, after model 1.

Curiously, the max air temperature for two of the dates is the same, so I tried it with date as a random effect instead of air temperature, which returned a lower AIC value and r^2^ value than model 2. It's likely that date accounts for more variation in other atmospheric conditions (i.e., temperature variation and mean) than maximum air temperature alone does. 

Water temperature data for the river is unavailable through the usual sources at the Westham Gage. Cartersville is available, and using max river temps from there in place of date returns similar AIC values. This might be a better predictive covariate than date and may help capture some of longer term variation in atmospheric conditions.

Continuous, untransformed shade actually provides a lower AIC value than binning it (0-25%, 25-50%, 50-75%, 75-100%) or arcsine transforming it.

It should be noted that there is some debate as to the validity and how to calculate r^2^ values for mixed models. See Nakagawa and Schielzeth 2012 in Methods in Ecology and Evolution. It may be better to do model validation based on its predictive ability.

Ryland suggested making a composite variable out of area and depth, because they are mildly correlated here. Mike may know how.


## Predicting from the Model

```{r}
require(prediction)
predict.df <- prediction(mod16, data = temp.df, calculate_se = TRUE)
predict.df$diffpred <- predict.df$fitted/predict.df$MaxWTemp_C

plot(x = predict.df$MaxWTemp_C, y = predict.df$diffpred)
plot(x = predict.df$MaxWTemp_C, y = predict.df$fitted)

mean(predict.df$diffpred)
```

Yep, so there's some bias here. It overestimates cool pools (by as much as 30%) and underestimates warm pools (by as much as 20%). Could be better. It looks like on average it overestimates things slightly, but not badly. This might not be a concern if there wasn't such a clear, linear trend between bias and temperature.

This isn't necessarily the end of the world, because we can be careful about how we propagate error. The predictions include std. errors, which could be incorporated into any future models stemming from this one.


## Some Quick "Occupancy" Modeling

This is really just a few quick logistic fits of temperature vs. presence/absence of mosquitoes and dragonflies, for the dates we have overlap on. For the JASM abstract.

```{r}
# Data manipulation
occ.df <- read.csv("occupancy_trimmed.csv")

occ.df$PoolID <- occ.df$ï..POOL_ID
occ.df$ï..POOL_ID <- NULL
occ.df$PoolID <- as.factor(occ.df$PoolID)
occ.df$Date <- occ.df$DATE
occ.df$DATE <- NULL
occ.df$Date <- as.factor(occ.df$Date)

temp.df$PoolID <- as.factor(temp.df$PoolID)
temp.df$Date <- as.factor(temp.df$Date)

occ_analysis.df <- merge(occ.df, temp.df, by = c("PoolID", "Date"))

# Quick and dirty logistic models
require(ggplot2)
logmod1 <- glm(MOSQUITO ~ MeanWTemp_C, family = binomial, data = occ_analysis.df)
summary(logmod1)

ggplot(occ_analysis.df, aes(y = MOSQUITO, x = MaxWTemp_C)) +
  geom_point() + 
  stat_smooth(method = "glm", se = TRUE, method.args = list(family = binomial))

logmod2 <- glm(DRAGONFLY ~ MaxWTemp_C, family = binomial, data = occ_analysis.df)
summary(logmod2)

ggplot(occ_analysis.df, aes(y = DRAGONFLY, x = MaxWTemp_C)) +
  geom_point() + 
  stat_smooth(method = "glm", se = TRUE, method.args = list(family = binomial))
```

So... Logistic fit for the dragonflies doesn't work at all, because there are very few pools in this set with dragons (like five?). The mosquito model suggests preference for warmer pools, but the r^2^ value is very low for both max and mean water temps (0.039 and 0.074 respectively) despite significant parameter estimates.
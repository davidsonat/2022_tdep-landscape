---
title: "Rock Pool Temperature Model"
author: "Andy"
date: "12/7/2021"
output:
  html_document:
    df_print: paged
---

```{r, echo = FALSE, warning = FALSE}
temponly.df <- read.csv("temperature_data.csv")
abiotic.df <- read.csv("abiotic_data.csv")
slabs.df <- read.csv("slabno.csv")
temp.df <- merge(temponly.df, abiotic.df)
temp.df <- merge(temp.df, slabs.df)
```

# Histograms

First, let's take a look at some of the data and explore it for correlations.

## Temperature Metrics

```{r, echo = FALSE, warning = FALSE}
hist(temp.df$MinWTemp)
hist(temp.df$MeanWTemp)
hist(temp.df$MaxWTemp)

plot(MeanWTemp_C ~ MaxWTemp_C, data = temp.df)
```


For this analysis, I'm choosing to focus in on maximum water temperature as our dependent variable, because it has a nice and pretty distribution and correlates well with mean water temperature (which is sort of what we're more interested in here). We could easily use mean temperature as well, but I am hesitant to use it because it does not represent a true daily "mean", because our data were collected over 8 hour periods and not a full 24 hours.

## Predictor Variables

```{r, echo = FALSE, warning = FALSE}
temp.df$DistRC_m <- as.numeric(temp.df$DistRC_m)

temp.df$Depth_cm <- as.numeric(temp.df$Depth_cm)
temp.df$Depth_m <- temp.df$Depth_cm/100

temp.df$SurfArea_cm2 <- as.numeric(temp.df$SurfArea_cm2)
temp.df$SurfArea_m2 <- temp.df$SurfArea_cm2/10000

temp.df$Volume_cm3 <- as.numeric(temp.df$Volume_cm3)
temp.df$Volume_m3 <- temp.df$Volume_cm3/1000000

temp.df$Pct_Shaded <- as.numeric(temp.df$Pct_Shaded)
temp.df$Pct_Shaded <- temp.df$Pct_Shaded/100

hist(temp.df$MaxATemp_C)
hist(temp.df$SurfArea_m2)
hist(temp.df$Volume_m3)
hist(temp.df$Depth_m)
hist(temp.df$Pct_Shaded)

temp.df$Date <- as.factor(temp.df$Date)

# Across pool variation
aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = max)
aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = min)
maxtemp_mean <- aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = mean)
maxtemp_sd <- aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = sd)
maxtemp_se <- maxtemp_sd$x/sqrt(length(temp.df$MaxWTemp_C))

aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = max)
aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = min)
aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = max) - aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = min)
mintemp_mean <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = mean)
mintemp_sd <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = sd)
mintemp_se <- mintemp_sd$x/sqrt(length(temp.df$MinWTemp_C))

temp.df$temp_range <-  temp.df$MaxWTemp_C - temp.df$MinWTemp_C
cor(temp.df$MaxWTemp_C, temp.df$cvWTemp_C)
cor(temp.df$MinWTemp_C, temp.df$temp_range)

# cv.plot <- ggplot(temp.df, aes(y = cvWTemp_C, x = MaxWTemp_C)) +
#   geom_point() +
#   theme_classic( base_size = 16, base_line_size = 1 ) +
#   ylab("Coeff. of Variation") +
#   xlab("Maximum Temperature (Â°C)") +
#   theme( panel.border = element_rect( color = "black", fill = NA, size = 0.75 ),
#          aspect.ratio = 1,
#          legend.position = "none")
# 
# ggsave( "Fig6.png",
#         plot = cv.plot,
#         units = c("mm"),
#         dpi = 300 )

# Within pool variation
mean(temp.df$temp_range)
sd(temp.df$temp_range)/sqrt(length(temp.df$temp_range))

mintemp_mean <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = mean)
mintemp_sd <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = sd)
mintemp_cv <- mintemp_mean/mintemp_sd
mintemp_cv
```


## Applying Transformations

Lots of right-skewing going on, so we'll do a few transformations. Z-scores for everything.

```{r, warning = FALSE}
temp.df$DistRC_Z <- (temp.df$DistRC_m - mean(temp.df$DistRC_m))/sd(temp.df$DistRC_m)
temp.df$Depth_Z <- (temp.df$Depth_cm - mean(temp.df$Depth_cm))/sd(temp.df$Depth_cm)
temp.df$SurfArea_Z <- (temp.df$SurfArea_cm2 - mean(temp.df$SurfArea_cm2))/sd(temp.df$SurfArea_cm2)
temp.df$Volume_Z <- (temp.df$Volume_cm3 - mean(temp.df$Volume_cm3))/sd(temp.df$Volume_cm3)
temp.df$Pct_Shaded_Z <- (temp.df$Pct_Shaded - mean(temp.df$Pct_Shaded))/sd(temp.df$Pct_Shaded)
temp.df$MaxRTemp_Z <- (temp.df$MaxRTemp_C - mean(temp.df$MaxRTemp_C))/sd(temp.df$MaxRTemp_C)
temp.df$MaxATemp_Z <- (temp.df$MaxATemp_C - mean(temp.df$MaxATemp_C))/sd(temp.df$MaxATemp_C)

temp.df$Date <- as.factor(temp.df$Date)
```


# Correlation Plots

```{r, echo = FALSE, warning = FALSE}
library(GGally)
temp2.df <- subset(temp.df, select = c("MaxWTemp_C", "MaxATemp_Z", "MaxRTemp_Z", "SurfArea_Z", "Depth_Z", "Pct_Shaded_Z", "DistRC_Z"))
ggpairs(data = temp2.df)
```

Area and depth look like good predictors, as does maximum river temperature and shade. Oddly, there is also some colinearity going on with some of our predictor variables, too (e.g., area x depth, shade x depth).


# Preliminary Modeling

Let's try making a basic GLMM using these variables, with area and depth as fixed effects and maximum air temperature as a random effect. We'll take a stepwise approach to model selection.

```{r, echo = FALSE, results = "hide", warning = FALSE}
library(glmmTMB)
library(performance)

# Depth, Area, Shade, and Air temp 
mod1 <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod1)

# Depth, Shade, and Air Temp
mod2 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod2)

# Area, Shade, and Air Temp
mod3 <- glmmTMB(MaxWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod3)

# Depth, Shade, and Area
mod4 <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z, data = temp.df )
summary(mod4)

# Depth, Area, and Air Temp
mod5 <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod5)

# Depth and Shade
mod6 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z, data = temp.df )
summary(mod6)

# Depth and Air Temp
mod7 <- glmmTMB(MaxWTemp_C ~ Depth_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod7)

# Depth and Area
mod8 <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z, data = temp.df )
summary(mod8)

# Area and Shade
mod9 <- glmmTMB(MaxWTemp_C ~ SurfArea_Z * Pct_Shaded_Z, data = temp.df )
summary(mod9)

# Area and Air Temp
mod10 <- glmmTMB(MaxWTemp_C ~ SurfArea_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod10)

# Shade and Air Temp
mod11 <- glmmTMB(MaxWTemp_C ~ Pct_Shaded_Z + (1 | MaxATemp_Z), data = temp.df )
summary(mod11)

# Area alone
mod12 <- glmmTMB(MaxWTemp_C ~ SurfArea_Z, data = temp.df )
summary(mod12)

# Shade alone
mod13 <- glmmTMB(MaxWTemp_C ~ Pct_Shaded_Z, data = temp.df )
summary(mod13)

# Depth alone
mod14 <- glmmTMB(MaxWTemp_C ~ Depth_Z, data = temp.df )
summary(mod14)

# Air Temp alone
mod15 <- glmmTMB(MaxWTemp_C ~ (1 | MaxATemp_Z), data = temp.df )
summary(mod15)
```

Model 2, which excludes area but includes depth, has the lowest AIC. It indicates that depth and shade both negatively impact maximum water temperatures, and there is an interaction - deep, shady pools are probably especially cool. Additionally, maximum air temperature does pull out as a significant random effect.

Curiously, the max air temperature for two of the dates is the same, so I tried it with date as a random effect instead of air temperature, which returned a lower AIC value than model 2. It's likely that date accounts for more variation in other atmospheric conditions (i.e., temperature variation and mean) than maximum air temperature alone does. 

Water temperature data for the river is unavailable through the usual sources at the Westham Gage. Cartersville is available, and using max river temps from there in place of date returns similar AIC values. This might be a better predictive covariate than date and may help capture some of longer term variation in atmospheric conditions.

```{r, echo = FALSE, results = "hide", warning = FALSE}
# River Temp as a random effect instead of date/air temp
library(MuMIn)
mod16 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + ( 1 | MaxRTemp_Z ), data = temp.df )
summary(mod16)
temp.df$residual <- residuals(mod16)
r.squaredGLMM(mod16)
```

Continuous, untransformed shade actually provides a lower AIC value than binning it (0-20%, 20-40%, 40-60%, 60-80%, 80-100%) or arcsine transforming it.

Including distance from river channel improves things too, but only marginally, and oddly, the parameter estimates for it aren't significant.

```{r, echo = FALSE, eval  = FALSE, results = "hide", warning = FALSE}
# mod17 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z * DistRC_Z + ( 1 | MaxRTemp_Z ), data = temp.df )
# summary(mod17)
# r.squaredGLMM(mod17)
```

Some other suggestions: river temperature as a fixed effect instead of a random effect, and pool ID as a random effect.

```{r, echo = FALSE, results = "hide", warning = FALSE}
temp.df$Pool_ID <- as.factor(temp.df$Pool_ID)
mod18 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + ( 1 | MaxRTemp_Z ) + (1 | Pool_ID), data = temp.df )
summary(mod18)
r.squaredGLMM(mod18)

mod19 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )
summary(mod19)
r.squaredGLMM(mod19)

mod20 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z * MaxRTemp_Z, data = temp.df )
summary(mod20)

mod21 <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )
summary(mod21)
r.squaredGLMM(mod21)
```

```{r, echo = FALSE, warning = FALSE}
library(AICcmodavg)
library(dplyr)
library(reshape2)
library(kimisc)
model_list <- nlist(mod1, mod2, mod3, mod4, mod5, mod6, mod7, mod8, mod9, mod10, mod11, mod12, mod13, mod14, mod15, mod16, mod18, mod19, mod20, mod21)
aic_table <- aictab(model_list)
model_vars <- sapply(model_list, function(x) gsub(":", "*", paste(names(x$frame), collapse = " + ")))
aic_table <- cbind(Modnames = names(model_vars), model_vars) %>%
  merge(aic_table, by = "Modnames") %>%
  arrange(AICc)
aic_table
```

Ultimately, the best model includes Pool ID as a random effect, and river temperature as a fixed effect. Its AIC is 977.9 (nothing else comes particularly close), with a marginal r^2^ of 0.52 and a conditional of 0.87. It's worth noting that Pool ID and lat/long coords (outlined below) are virtually interchangeable here, so we will use Pool ID because it makes the math and interpretation simpler.

```{r}
library(dotwhisker)
library(broom)
library(broom.mixed)
plot1.df <- broom::tidy(mod21)
plot1.df$model <- c("cond", "cond", "cond", "cond", "cond", "cond", "cond")
plot1.df <- plot1.df[-c(1,6,7),]
plot1.df$term <- c("Depth (cm)", "Shading", "Max River Temp. (Â°C)", "Depth:Shading")
coeff.plot <- dwplot(plot1.df, 
       vline = geom_vline(xintercept = 0, colour = "grey80", linetype = 2, size = 1), 
       dot_args = list(size = 4), 
       line_args = list(size = 6)) + 
  theme_classic( base_size = 16, base_line_size = 1 ) + 
  xlab("Coefficient Estimate") +
  theme( panel.border = element_rect( color = "black", fill = NA, size = 0.75 ),
         aspect.ratio = 1,
         legend.position = "none")

ggsave( "Fig2.png",
        plot = coeff.plot,
        width = 164,
        height = 164,
        units = c("mm"),
        dpi = 300 )
```


## Predicting from the Model

```{r, echo = FALSE, warning = FALSE}
library(prediction)
predict.df <- prediction(mod21, data = temp.df, calculate_se = TRUE)
predict.df$diffpred <- predict.df$fitted/predict.df$MaxWTemp_C

plot(x = predict.df$MaxWTemp_C, y = predict.df$diffpred)
mean(predict.df$diffpred)
```

Interesting. Some over/underestimating at the tails, but most pools are within +/- 5%.

Million dollar question: can we plot it?

```{r, echo = FALSE, warning = FALSE}
library(ggplot2)
library(viridis)

ggplot(data = predict.df, aes(y = lat, x = long, colour = fitted)) +
  geom_point(size = 3.5, fill = "black") + 
  scale_colour_viridis() +
  theme(panel.background = element_rect(fill = "black", colour = "black", size = 0.5, linetype = "solid"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  labs(colour = "Temp (Â°C)")
```

The next step will be to challenge the model (and ourselves) a bit. Can we simulate a day on which the river temperature is 25Â°C, as an example, and predict temperatures for the whole system? I will need a data set containing pool dimensions and the densiometer data for the full system. Fortunately, I've made one.

```{r, echo = FALSE, warning = FALSE}
testdata.df <- read.csv("abiotic_data.csv")
testdata.df$Depth_cm <- as.numeric(testdata.df$Depth_cm)
testdata.df$Pct_Shaded <- as.numeric(testdata.df$Pct_Shaded)
testdata.df$Pool_ID <- as.factor(testdata.df$Pool_ID)
testdata.df$MaxRTemp_Z <- rep(0, nrow(testdata.df))
testdata.df$Pct_Shaded <- testdata.df$Pct_Shaded/100
testdata.df$Depth_Z <- (testdata.df$Depth_cm - mean(testdata.df$Depth_cm, na.rm = TRUE))/sd(testdata.df$Depth_cm, na.rm = TRUE)
testdata.df$Pct_Shaded_Z <- (testdata.df$Pct_Shaded - mean(testdata.df$Pct_Shaded, na.rm = TRUE))/sd(testdata.df$Pct_Shaded, na.rm = TRUE)

testdata.df <- testdata.df[!is.na(testdata.df$Depth_Z),]
testdata.df <- testdata.df[!is.na(testdata.df$Pct_Shaded_Z),]
predict2.df <- predict(mod21, newdata = testdata.df, allow.new.levels = TRUE, se.fit = TRUE, na.rm = TRUE)
predicted.df <- cbind(testdata.df, predict2.df)

temp_plot <- ggplot(data = predicted.df, aes(y = lat, x = long, colour = fit)) +
  geom_point(size = 1.5, fill = "black") + 
  scale_colour_viridis() + 
  theme_classic( base_size = 12, base_line_size = 1 ) + 
  theme(panel.background = element_rect(fill = "black", colour = "black", size = 0.5, linetype = "solid"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        aspect.ratio = 1) +
  labs(colour = "Temp (Â°C)")

write.csv(predicted.df, file = "output_fullsys.csv")
ggsave(temp_plot, file = "plot_fullsys.png", width = 14, height = 10, units = "cm")

```

Awesome. Lastly, let's convert these temperature estimates into a standardized z-score that measures how relatively "hot" a pool gets.

```{r, echo = FALSE, warning = FALSE}
predicted.df$z_score <- (predicted.df$fit - mean(predicted.df$fit))/sd(predicted.df$fit)

predicted.df$DistRC_m <- NULL
predicted.df$SurfArea_cm2 <- NULL
predicted.df$Volume_cm3 <- NULL
predicted.df$Notes <- NULL
predicted.df$MaxRTemp_C <- NULL
predicted.df$MaxRTemp_Z <- NULL
# predicted.df$pos <- NULL
# predicted.df$group <- NULL
predicted.df$logDepth <- NULL

colnames(predicted.df) <- c("Pool_ID", "lat", "long", "Depth_cm", "Pct_Shaded", "Depth_Z", "Pct_Shaded_Z", "Temp_Predicted_C","Temp_StdErr", "Temp_Zscore")

hist(predicted.df$Temp_Zscore)

write.csv(predicted.df, "temp_predictions.csv", row.names = FALSE)
saveRDS(mod21, "temp_model.rds")
```


## Spatially Explicit Modeling

This section is deprecated with the realization that Pool ID is as good of a random effect as lat/long. Preserving the code here for posterity.

```{r, eval = FALSE, echo = FALSE}
library(sp)
coordinates(temp.df) <- ~long + lat
bubble(temp.df, "residual")

temp.df$pos <- numFactor(temp.df$long, temp.df$lat)
temp.df$group <- factor(rep(1, nrow(temp.df)))

library(sjPlot)
spatial.glmm <- glmmTMB(MaxWTemp_C ~ logDepth * Pct_Shaded + ( 1 | MaxRTemp_C ) + exp(pos + 0 | group), data = temp.df )
tab_model(spatial.glmm, show.aic = TRUE, show.loglik = TRUE)

library(DHARMa)
DHARMa::testDispersion(spatial.glmm)
DHARMa::testDispersion(spatial.glmm, type="PearsonChisq", 
         alternative="greater")
sim.resids <- DHARMa::simulateResiduals(spatial.glmm, 250)
plot(sim.resids)
model_performance(spatial.glmm)
r.squaredGLMM(spatial.glmm)

model_list <- nlist(mod16, mod18, mod19, mod20, mod21, mod22, spatial.glmm)
aic_table <- aictab(model_list)
model_vars <- sapply(model_list, function(x) gsub(":", "*", paste(names(x$frame), collapse = " + ")))
aic_table <- cbind(Modnames = names(model_vars), model_vars) %>%
  merge(aic_table, by = "Modnames") %>%
  arrange(AICc)
aic_table

spatial.glmm2 <- glmmTMB(MaxWTemp_C ~ logDepth * Pct_Shaded + ( 1 | MaxRTemp_C ) + ( 1 | Pool_ID ) + exp(pos + 0 | group), data = temp.df )
tab_model(spatial.glmm2, show.aic = TRUE, show.loglik = TRUE)

spatial.glmm3 <- glmmTMB(MaxWTemp_C ~ logDepth * Pct_Shaded * MaxRTemp_C + ( 1 | Pool_ID ) + exp(pos + 0 | group), data = temp.df )
tab_model(spatial.glmm3, show.aic = TRUE, show.loglik = TRUE)

model_list <- nlist(mod16, mod18, mod19, mod20, mod21, mod22, spatial.glmm, spatial.glmm2, spatial.glmm3)
aic_table <- aictab(model_list)
model_vars <- sapply(model_list, function(x) gsub(":", "*", paste(names(x$frame), collapse = " + ")))
aic_table <- cbind(Modnames = names(model_vars), model_vars) %>%
  merge(aic_table, by = "Modnames") %>%
  arrange(AICc)
aic_table

temp.df$slab <- as.factor(temp.df$slab)
slabs.glmm <- glmmTMB(MaxWTemp_C ~ logDepth * Pct_Shaded + ( 1 | Date) + ( 1 | slab), data = temp.df )
tab_model(slabs.glmm, show.aic = TRUE, show.loglik = TRUE)
```


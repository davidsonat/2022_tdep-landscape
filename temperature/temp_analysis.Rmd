---
title: "Rock Pool Temperature Model"
author: "Andy"
date: "12/7/2021"
output:
  html_document:
    df_print: paged
---

```{r, echo = FALSE, warning = FALSE}
library(ggplot2)
library(cowplot)
library(GGally)
library(AICcmodavg)
library(dplyr)
library(reshape2)
library(kimisc)
library(glmmTMB)
library(performance)
library(MuMIn)
library(prediction)
library(viridis)

temponly.df <- read.csv("temperature_data.csv")
abiotic.df <- read.csv("abiotic_data.csv")
temp.df <- merge(temponly.df, abiotic.df)
```

# Histograms

First, let's take a look at some of the data and explore it for correlations.

## Temperature Metrics

```{r, echo = FALSE, warning = FALSE}
max.hist <- ggplot(temp.df, aes(x = MaxWTemp_C)) +
  geom_histogram(binwidth = 2, colour = "black", fill = "grey80") +  
  theme_classic( base_size = 12, base_line_size = 1 ) + 
  scale_y_continuous( expand = c(0, 0), limits = c(0, 60) ) +
  scale_x_continuous( limits = c(15, 45)) +
  xlab("Max Temperature (°C)") +
  ylab("Frequency") +
  theme( panel.border = element_rect( color = "black", fill = NA, size = 0.75 ),
         legend.position = "none",
         aspect.ratio = 1)


min.hist <- ggplot(temp.df, aes(x = MinWTemp_C)) +
  geom_histogram(binwidth = 2, colour = "black", fill = "grey80") +  
  theme_classic( base_size = 12, base_line_size = 1 ) + 
  scale_y_continuous( expand = c(0, 0), limits = c(0, 60) ) +
  scale_x_continuous( limits = c(15, 45)) +
  xlab("Min Temperature (°C)") +
  ylab("Frequency") +
  theme( panel.border = element_rect( color = "black", fill = NA, size = 0.75 ),
         legend.position = "none",
         aspect.ratio = 1)
```


For this analysis, I'm choosing to focus in on maximum water temperature as our dependent variable, because it has a nice and pretty distribution and correlates well with mean water temperature (which is sort of what we're more interested in here). We could easily use mean temperature as well, but I am hesitant to use it because it does not represent a true daily "mean", because our data were collected over 8 hour periods and not a full 24 hours.

## Predictor Variables

```{r, echo = FALSE, warning = FALSE}
temp.df$DistRC_m <- as.numeric(temp.df$DistRC_m)

temp.df$Depth_cm <- as.numeric(temp.df$Depth_cm)
temp.df$Depth_m <- temp.df$Depth_cm/100

temp.df$SurfArea_cm2 <- as.numeric(temp.df$SurfArea_cm2)
temp.df$SurfArea_m2 <- temp.df$SurfArea_cm2/10000

temp.df$Volume_cm3 <- as.numeric(temp.df$Volume_cm3)
temp.df$Volume_m3 <- temp.df$Volume_cm3/1000000

temp.df$Pct_Shaded <- as.numeric(temp.df$Pct_Shaded)
temp.df$Pct_Shaded <- temp.df$Pct_Shaded/100

hist(temp.df$MaxATemp_C)
hist(temp.df$SurfArea_m2)
hist(temp.df$Volume_m3)
hist(temp.df$Depth_m)
hist(temp.df$Pct_Shaded)

temp.df$Date <- as.factor(temp.df$Date)

# Across pool variation
aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = max)
aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = min)
maxtemp_mean <- aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = mean)
maxtemp_sd <- aggregate(temp.df$MaxWTemp_C, by = list(temp.df$Date), FUN = sd)
maxtemp_se <- maxtemp_sd$x/sqrt(length(temp.df$MaxWTemp_C))

aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = max)
aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = min)
aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = max) - aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = min)
mintemp_mean <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = mean)
mintemp_sd <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = sd)
mintemp_se <- mintemp_sd$x/sqrt(length(temp.df$MinWTemp_C))

temp.df$temp_range <-  temp.df$MaxWTemp_C - temp.df$MinWTemp_C
cor(temp.df$MaxWTemp_C, temp.df$cvWTemp_C)
cor(temp.df$MinWTemp_C, temp.df$temp_range)

cv.hist <- ggplot(temp.df, aes(x = temp_range)) +
  geom_histogram(binwidth = 2, colour = "black", fill = "grey80") +  
  theme_classic( base_size = 12, base_line_size = 1 ) + 
  scale_y_continuous( expand = c(0, 0) ) +
  xlab("Coefficient of Variation") +
  ylab("Frequency") +
  theme( panel.border = element_rect( color = "black", fill = NA, size = 0.75 ),
         legend.position = "none",
         aspect.ratio = 1)

Fig2.plot <- plot_grid( max.hist, min.hist, cv.hist,
                        labels = c("a)", "b)", "c)"),
                        label_x = 0.34,
                        nrow = 3,
                        align = "hv" )


# ggsave( "../figs/Fig2.png",
#         plot = Fig2.plot,
#         units = c("mm"),
#         dpi = 300 )


# Within pool variation
mean(temp.df$temp_range)
sd(temp.df$temp_range)/sqrt(length(temp.df$temp_range))

mintemp_mean <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = mean)
mintemp_sd <- aggregate(temp.df$MinWTemp_C, by = list(temp.df$Date), FUN = sd)
mintemp_cv <- mintemp_mean/mintemp_sd
mintemp_cv
```


## Applying Transformations

Lots of right-skewing going on, so we'll do a few transformations. Z-scores for everything.

```{r, warning = FALSE}
temp.df$DistRC_Z <- (temp.df$DistRC_m - mean(temp.df$DistRC_m))/sd(temp.df$DistRC_m)
temp.df$Depth_Z <- (temp.df$Depth_cm - mean(temp.df$Depth_cm))/sd(temp.df$Depth_cm)
temp.df$SurfArea_Z <- (temp.df$SurfArea_cm2 - mean(temp.df$SurfArea_cm2))/sd(temp.df$SurfArea_cm2)
temp.df$Volume_Z <- (temp.df$Volume_cm3 - mean(temp.df$Volume_cm3))/sd(temp.df$Volume_cm3)
temp.df$Pct_Shaded_Z <- (temp.df$Pct_Shaded - mean(temp.df$Pct_Shaded))/sd(temp.df$Pct_Shaded)
temp.df$MaxRTemp_Z <- (temp.df$MaxRTemp_C - mean(temp.df$MaxRTemp_C))/sd(temp.df$MaxRTemp_C)
temp.df$MaxATemp_Z <- (temp.df$MaxATemp_C - mean(temp.df$MaxATemp_C))/sd(temp.df$MaxATemp_C)

temp.df$Date <- as.factor(temp.df$Date)
```


# Correlation Plots

```{r, echo = FALSE, warning = FALSE}
temp2.df <- subset(temp.df, select = c("MaxWTemp_C", "MaxATemp_Z", "MaxRTemp_Z", "SurfArea_Z", "Depth_Z", "Pct_Shaded_Z", "DistRC_Z"))
# ggpairs(data = temp2.df)
```

Area and depth look like good predictors, as does maximum river temperature and shade. Oddly, there is also some colinearity going on with some of our predictor variables, too (e.g., area x depth, shade x depth).

# Max Temperature Modeling

Let's try making a basic GLMM using these variables, with area, depth, shade, and river temp as fixed effects and pool ID as a random effect. We'll take a stepwise approach to model selection.

```{r, echo = FALSE, results = "hide", warning = FALSE}
temp.cand.models <- list()

# Depth, Area, Shade, and River Temp 
temp.cand.models[[1]] <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth, Area, Shade
temp.cand.models[[2]] <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Depth, Area, River Temp
temp.cand.models[[3]] <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth, Shade, River Temp
temp.cand.models[[4]] <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Area, Shade, River Temp
temp.cand.models[[5]] <- glmmTMB(MaxWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth and Area
temp.cand.models[[6]] <- glmmTMB(MaxWTemp_C ~ Depth_Z * SurfArea_Z + (1 | Pool_ID), data = temp.df )

# Depth and Shade
temp.cand.models[[7]] <- glmmTMB(MaxWTemp_C ~ Depth_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Depth and River Temp
temp.cand.models[[8]] <- glmmTMB(MaxWTemp_C ~ Depth_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Area and Shade
temp.cand.models[[9]] <- glmmTMB(MaxWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Area and River Temp
temp.cand.models[[10]] <- glmmTMB(MaxWTemp_C ~ SurfArea_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Shade and River Temp
temp.cand.models[[11]] <- glmmTMB(MaxWTemp_C ~ Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth alone
temp.cand.models[[12]] <- glmmTMB(MaxWTemp_C ~ Depth_Z + (1 | Pool_ID), data = temp.df )

# Area alone
temp.cand.models[[13]] <- glmmTMB(MaxWTemp_C ~ SurfArea_Z + (1 | Pool_ID), data = temp.df )

# Shade alone
temp.cand.models[[14]] <- glmmTMB(MaxWTemp_C ~ Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# River temp alone
temp.cand.models[[15]] <- glmmTMB(MaxWTemp_C ~ MaxRTemp_Z + (1 | Pool_ID), data = temp.df )
```

Continuous, untransformed shade actually provides a lower AIC value than binning it (0-20%, 20-40%, 40-60%, 60-80%, 80-100%) or arcsine transforming it.

Including distance from river channel improves things too, but only marginally, and oddly, the parameter estimates for it aren't significant.

```{r, echo = FALSE, warning = FALSE}
# mod.names <- list()
# for (i in 1:length(temp.cand.models)){
# mod.names[i] <- as.character(formula(temp.cand.models[[i]], component = c("cond")))
# }
aic_table <- aictab(cand.set = temp.cand.models, sort = TRUE)
summary(temp.cand.models[[7]])
# write.csv(aic_table, file = "../temperature/aic_table.csv")
```

Ultimately, the best model includes Pool ID as a random effect, and depth and shading as fixed effects. Its AIC is 999.98 (nothing else comes particularly close), with a marginal r^2^ of 0.52 and a conditional of 0.87. It's worth noting that Pool ID and lat/long coords (outlined below) are virtually interchangeable here, so we will use Pool ID because it makes the math and interpretation simpler.

```{r}
library(dotwhisker)
library(broom)
library(broom.mixed)
plot1.df <- broom::tidy(temp.cand.models[[4]])
plot1.df$model <- c("cond", "cond", "cond", "cond", "cond", "cond", "cond")
plot1.df <- plot1.df[-c(1,6,7),]
plot1.df$term <- c("Depth (cm)", "Shading", "Max River Temp. (°C)", "Depth:Shading")
coeff.plot <- dwplot(plot1.df, 
       vline = geom_vline(xintercept = 0, colour = "grey80", linetype = 2, size = 1), 
       dot_args = list(size = 4), 
       line_args = list(size = 6)) + 
  theme_classic( base_size = 16, base_line_size = 1 ) + 
  xlab("Coefficient Estimate") +
  theme( panel.border = element_rect( color = "black", fill = NA, size = 0.75 ),
         aspect.ratio = 1,
         legend.position = "none")

# ggsave( "../figs/Fig2.png",
#         plot = coeff.plot,
#         width = 164,
#         height = 164,
#         units = c("mm"),
#         dpi = 300 )
```

## Predicting from the Model

```{r, echo = FALSE, warning = FALSE}
predict.df <- prediction(mod21, data = temp.df, calculate_se = TRUE)
predict.df$diffpred <- predict.df$fitted/predict.df$MaxWTemp_C

plot(x = predict.df$MaxWTemp_C, y = predict.df$diffpred)
mean(predict.df$diffpred)
```

Interesting. Some over/underestimating at the tails, but most pools are within +/- 5%.

Million dollar question: can we plot it?

```{r, echo = FALSE, warning = FALSE}
ggplot(data = predict.df, aes(y = lat, x = long, colour = fitted)) +
  geom_point(size = 3.5, fill = "black") + 
  scale_colour_viridis() +
  theme(panel.background = element_rect(fill = "black", colour = "black", size = 0.5, linetype = "solid"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  labs(colour = "Temp (°C)")
```

The next step will be to challenge the model (and ourselves) a bit. Can we simulate a day on which the river temperature is 25°C, as an example, and predict temperatures for the whole system? I will need a data set containing pool dimensions and the densiometer data for the full system. Fortunately, I've made one.

```{r, echo = FALSE, warning = FALSE}
testdata.df <- read.csv("abiotic_data.csv")
testdata.df$Depth_cm <- as.numeric(testdata.df$Depth_cm)
testdata.df$Pct_Shaded <- as.numeric(testdata.df$Pct_Shaded)
testdata.df$SurfArea_cm2 <- as.numeric(testdata.df$SurfArea_cm2)
testdata.df$Pool_ID <- as.factor(testdata.df$Pool_ID)
testdata.df$MaxRTemp_Z <- rep(0, nrow(testdata.df))
testdata.df$Pct_Shaded <- testdata.df$Pct_Shaded/100
testdata.df$Depth_Z <- (testdata.df$Depth_cm - mean(testdata.df$Depth_cm, na.rm = TRUE))/sd(testdata.df$Depth_cm, na.rm = TRUE)
testdata.df$Pct_Shaded_Z <- (testdata.df$Pct_Shaded - mean(testdata.df$Pct_Shaded, na.rm = TRUE))/sd(testdata.df$Pct_Shaded, na.rm = TRUE)
testdata.df$SurfArea_Z <- (testdata.df$SurfArea_cm2 - mean(testdata.df$SurfArea_cm2, na.rm = TRUE))/sd(testdata.df$SurfArea_cm2, na.rm = TRUE)

testdata.df <- testdata.df[!is.na(testdata.df$Depth_Z),]
testdata.df <- testdata.df[!is.na(testdata.df$Pct_Shaded_Z),]
testdata.df <- testdata.df[!is.na(testdata.df$SurfArea_cm2),]

predict2.df <- predict(temp.cand.models[[4]], newdata = testdata.df, allow.new.levels = TRUE, se.fit = TRUE, na.rm = TRUE)
predicted.df <- cbind(testdata.df, predict2.df)

names(predicted.df)[names(predicted.df) == 'fit'] <- 'MaxTemp_Predicted_C'
names(predicted.df)[names(predicted.df) == 'se.fit'] <- 'MaxTemp_SE'

predicted.df$MaxTemp_Z <- (predicted.df$MaxTemp_Predicted_C - mean(predicted.df$MaxTemp_Predicted_C))/sd(predicted.df$MaxTemp_Predicted_C)
```



# Min Temperature Model

```{r}
min.cand.models <- list()

# Depth, Area, Shade, and River Temp 
min.cand.models[[1]] <- glmmTMB(MinWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth, Area, Shade
min.cand.models[[2]] <- glmmTMB(MinWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Depth, Area, River Temp
min.cand.models[[3]] <- glmmTMB(MinWTemp_C ~ Depth_Z * SurfArea_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth, Shade, River Temp
min.cand.models[[4]] <- glmmTMB(MinWTemp_C ~ Depth_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Area, Shade, River Temp
min.cand.models[[5]] <- glmmTMB(MinWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth and Area
min.cand.models[[6]] <- glmmTMB(MinWTemp_C ~ Depth_Z * SurfArea_Z + (1 | Pool_ID), data = temp.df )

# Depth and Shade
min.cand.models[[7]] <- glmmTMB(MinWTemp_C ~ Depth_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Depth and River Temp -- does not converge
# min.cand.models[[8]] <- glmmTMB(MinWTemp_C ~ Depth_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Area and Shade
min.cand.models[[8]] <- glmmTMB(MinWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Area and River Temp
min.cand.models[[9]] <- glmmTMB(MinWTemp_C ~ SurfArea_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Shade and River Temp
min.cand.models[[10]] <- glmmTMB(MinWTemp_C ~ Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth alone
min.cand.models[[11]] <- glmmTMB(MinWTemp_C ~ Depth_Z + (1 | Pool_ID), data = temp.df )

# Area alone
min.cand.models[[12]] <- glmmTMB(MinWTemp_C ~ SurfArea_Z + (1 | Pool_ID), data = temp.df )

# Shade alone
min.cand.models[[13]] <- glmmTMB(MinWTemp_C ~ Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# River temp alone
min.cand.models[[14]] <- glmmTMB(MinWTemp_C ~ MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

mod.names <- list()
# for (i in 1:length(min.cand.models)){
# mod.names[i] <- as.character(formula(min.cand.models[[i]], component = c("cond")))
# }
aic_table2 <- aictab(cand.set = min.cand.models, sort = TRUE)

summary(min.cand.models[[1]])
r2(min.cand.models[[1]])
```

The full model is the best, indicating that shadier pools with higher surface area have lower min temps, while deeper pools and warmer river days mean higher min temps. R2 values are decent. Conditional of 0.869, marginal of 0.834.

```{r, echo = FALSE, warning = FALSE}
predict3.df <- predict(min.cand.models[[1]], newdata = testdata.df, allow.new.levels = TRUE, se.fit = TRUE, na.rm = TRUE)
predicted.df <- cbind(predicted.df, predict3.df)

names(predicted.df)[names(predicted.df) == 'fit'] <- 'MinTemp_Predicted_C'
names(predicted.df)[names(predicted.df) == 'se.fit'] <- 'MinTemp_SE'
```

# CV Temperature Model

```{r}
cv.cand.models <- list()

# Depth, Area, Shade, and River Temp 
cv.cand.models[[1]] <- glmmTMB(cvWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth, Area, Shade
cv.cand.models[[2]] <- glmmTMB(cvWTemp_C ~ Depth_Z * SurfArea_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Depth, Area, River Temp
cv.cand.models[[3]] <- glmmTMB(cvWTemp_C ~ Depth_Z * SurfArea_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth, Shade, River Temp
cv.cand.models[[4]] <- glmmTMB(cvWTemp_C ~ Depth_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Area, Shade, River Temp
cv.cand.models[[5]] <- glmmTMB(cvWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth and Area
cv.cand.models[[6]] <- glmmTMB(cvWTemp_C ~ Depth_Z * SurfArea_Z + (1 | Pool_ID), data = temp.df )

# Depth and Shade
cv.cand.models[[7]] <- glmmTMB(cvWTemp_C ~ Depth_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Depth and River Temp
cv.cand.models[[8]] <- glmmTMB(cvWTemp_C ~ Depth_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Area and Shade
cv.cand.models[[9]] <- glmmTMB(cvWTemp_C ~ SurfArea_Z * Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# Area and River Temp
cv.cand.models[[10]] <- glmmTMB(cvWTemp_C ~ SurfArea_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Shade and River Temp
cv.cand.models[[11]] <- glmmTMB(cvWTemp_C ~ Pct_Shaded_Z + MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# Depth alone
cv.cand.models[[12]] <- glmmTMB(cvWTemp_C ~ Depth_Z + (1 | Pool_ID), data = temp.df )

# Area alone
cv.cand.models[[13]] <- glmmTMB(cvWTemp_C ~ SurfArea_Z + (1 | Pool_ID), data = temp.df )

# Shade alone
cv.cand.models[[14]] <- glmmTMB(cvWTemp_C ~ Pct_Shaded_Z + (1 | Pool_ID), data = temp.df )

# River temp alone
cv.cand.models[[15]] <- glmmTMB(cvWTemp_C ~ MaxRTemp_Z + (1 | Pool_ID), data = temp.df )

# mod.names <- list()
# for (i in 1:length(min.cand.models)){
# mod.names[i] <- as.character(formula(min.cand.models[[i]], component = c("cond")))
# }
aic_table3 <- aictab(cand.set = cv.cand.models, sort = TRUE)

summary(cv.cand.models[[4]])
r2(cv.cand.models[[4]])

cor(temp.df$cvWTemp_C, temp.df$MaxWTemp_C)
cor(temp.df$cvWTemp_C, temp.df$MinWTemp_C)
cor(temp.df$MinWTemp_C, temp.df$MaxWTemp_C)


predict4.df <- predict(cv.cand.models[[4]], newdata = testdata.df, allow.new.levels = TRUE, se.fit = TRUE, na.rm = TRUE)
predicted.df <- cbind(predicted.df, predict4.df)

names(predicted.df)[names(predicted.df) == 'fit'] <- 'CVTemp_Predicted_C'
names(predicted.df)[names(predicted.df) == 'se.fit'] <- 'CVTemp_SE'

write.csv(predicted.df, file = "temp_predictions.csv")
```

Model 4 wins here, but the coefficient estimates are all pretty small. It looks like depth, shading, and river temperature all reduce temperature variability. R2 is ok, but a lot of it seems to be coming from the random effect of Pool ID. Conditional is 0.822, marginal is only 0.385. It's worth noting too that cv is correlated with both maximum (r = 0.66; so warmer = more variation) and minimum temps (r = -0.55; so cooler = more variation).

